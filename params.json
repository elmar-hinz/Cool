{"name":"Cool","tagline":"a tiny autowiring PHP framework","body":"======================================\r\nCool - a tiny autowiring PHP framework\r\n======================================\r\n\r\n * Author: Elmar Hinz <t3elmar@googlemail.com>\r\n * Homepage: \r\n * Version: 0.x.x\r\n * Stability: Alpha/Usable\r\n * License: MIT\r\n * Last update: See [ChangeLog](https://github.com/t3elmar/Cool/blob/master/ChangeLog)\r\n * OS: tested on POSIX i.e. Mac OS X, Unix, Linux, BSD\r\n * Dependencies: \r\n   * php > 5.3\r\n   * git (recommended for installation)\r\n * The dependencies ship under their own licenses and are not part of this program\r\n\t\r\nFeatures\r\n========\r\n\r\n- [x] Autowiring\r\n- [x] Singletons\r\n- [x] Services\r\n- [ ] Hooks\r\n- [x] Modularization\r\n- [x] Autoloading\r\n\r\nInstallation\r\n============\r\n\r\n\tgit clone git@github.com:t3elmar/Cool.git\r\n\r\nAutowiring - Dependency injection for dummies\r\n=============================================\r\n\r\n```php\r\nclass People { ... }\r\nclass Beer   { ... }\r\nclass Music  { ... } \r\n\r\nclass Party {\r\n\tfunction __construct(People $people, Beer $beer, Music $music) {\r\n\t\t...\r\n\t}\r\n}\r\n\r\n$container = new \\Cool\\Container();\r\n$party = $container->getInstance('Party');\r\n\r\n// And the party is up and running ...\r\n```\r\n\r\nAutowiring, the details\r\n-----------------------\r\n\r\nAutowiring is triggert by a call to `getInstance($classname)` \r\nof the container.  It is based on the signature of the constructor. \r\n\r\nFor each parameter in the construtor definition a classname has \r\nto be specified. Else it doesn't works and an error is thrown. \r\nIt tries to to create an instance for each parameter \r\nby a recursive call to `getInstance`.\r\n\r\nIf `getInstance()` doesn't do what you want, you can still fall back\r\nto the static call to `new` or implement your own factory.\r\n\r\n**Out-look**\r\n\r\n> The recursive auto-instantiation of objects is a nice feature,\r\n> but not the definition and strength of dependency injection.\r\n> The strenght is flexibility. Future versions will provide mechanism,\r\n> to replace classes (or interfaces in general) by subclasses \r\n> through configuration.\r\n\r\n`getInstance` supports the singleton management of the container.\r\n\r\nSingletons\r\n==========\r\n\r\nBy implementing the interface `\\Cool\\Singleton` an object is managed as \r\nSingleton by the container, as long as it called by the conatainer\r\nmethods `getInstance`, `getService` or `getHook`.\r\n\r\n```php\r\nclass SantaClaus implements \\Cool\\Singleton { ... }\r\n```\r\n\r\nThe interface itself is empty. It serves as a flag.\r\n\r\nServices\r\n========\r\n\r\nA service is a class, that implements a service interface.\r\n\r\n```php\r\nclass PizzaCourier implements PizzaService { ... }\r\n```\r\n\r\nThis interface defines the type of the service. \r\nIt must extend `\\Cool\\Service`.\r\n\r\n```php\r\ninterface PizzaService extends \\Cool\\Service { ... }\r\n```\r\n\r\nInterface `\\Cool\\Service` has one method `canServe($mixedCriteria)`. \r\n\r\nWhen it's method `getService($serviceType , $mixedCriteria)` is called,\r\nthe container asks all classes of the given service type, if they \r\ncould serve the request. The first service that answers with TRUE \r\nis the winner. It is instantiated and returned ready to do the job. \r\n\r\nThis is a rather simple algorythm to find the winnig service, but it's \r\nsimplicity by intention. Not to much should happen behind the scenes.\r\n\r\n```php\r\n// ... Concierge get me a pizza service! \r\n// ... We have a surprising monday party and the fridge is empty.\r\n\r\n$pizzaService = $container->getService(\r\n\t\t\t\t'MyModule\\PizzaService', array('dayOfWeek' => 'monday'));\r\n\r\n//  Concierge wiring some pizza services, \r\n//  all closed on monday, until suddenly ...\r\n\r\nclass PizzaCourier implements PizzaService {  \r\n\t// ...\r\n\tstatic public function canServe($mixedCriteria) { \r\n\t\treturn ($mixedCriteria['dayOfWeek'] != 'tuesday');\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n\r\n**Hint:**\r\n\r\n> It depends on the service type, what `canServe` uses as $mixedCriteria \r\n> and how it evaluates its answer. If you don't set a stricter type for\r\n> $mixedCriteria in the interface definition,  you should at least \r\n> document it in that place.\r\n\r\n**Hint:**\r\n\r\n> canServe is a **static** method, a **class method**.\r\n>\r\n> To get inheritance work with static methods and variables\r\n> **late static bindings** are youre friends:\r\n> http://www.php.net/manual/en/language.oop5.late-static-bindings.php\r\n\r\nServices are autoregistered. They must stay in a module directory\r\nnamed `Services/` to work, while the interface definition belongs \r\ninto `Interfaces/`.\r\n\r\n\tMyModule/Interfaces/PizzaService.php\r\n\tMyModule/Services/PizzaCourier.php\r\n\r\n**Hint:**\r\n\r\n> Instantiation is delegated to `getInstance`. That means that a service \r\n> must provide a construtor that satisfies the criteria of `getInstance`.\r\n\r\nHooks\r\n=====\r\n\r\nNot implemented yet.\r\n\r\nModularization\r\n==============\r\n\r\nA module is created by putting a directory into `Modules`.\r\n\r\n\tCool/Modules/MyModule/\r\n\r\nThe Module hierarchy is flat. If you want to introduce hierarchy,\r\nyou have to do this in Form of the name. \r\n\r\n\tCool/Modules/MyCompanyMySuperModule/\r\n\r\nThe subdirectories `Interfaces`, `Classes`, `Hooks` and `Services`\r\nare the places where the autoloader is looking for. If your pathes\r\ndiffer from this, you have to provide your own loading mechanism.\r\n\r\n\tMyModule/Interfaces/\r\n\tMyModule/Classes/\r\n\tMyModule/Hooks/\r\n\tMyModule/Services/\r\n\r\nHooks and Services must stay in their matching directory to \r\nbe autoregistered.\r\n\r\n\tMyModule/Hooks/\r\n\tMyModule/Services/\r\n\r\nOther recommended Directories\r\n\r\n\tMyModule/Configuration/\r\n\tMyModule/Executables/\r\n\tMyModule/Documentation/\r\n\tMyModule/Tests/\r\n\r\n\r\nCoding guidelines\r\n=================\r\n\r\nThe coding guidelines are recommendations. They don't differ from\r\nthe up-to-date mainstream:\r\n\r\n* Use CamelCase as far as possible.\r\n* Classnames start uppercase, functions and variables lowercase.\r\n* Constants are all uppercase: TRUE, FALSE \r\n* Respect the security requirements of PHP programming\r\n* Wrap all PHP code into classes, even configurations.\r\n* Use namespaces.\r\n* Write configurations as PHP array for now.\r\n* Put a license into your module.\r\n* When you call code from other modules, adhere their licences.\r\n  They may not be as liberal as the Cool framework itself.\r\n\r\n\r\nGoals of the design\r\n===================\r\n\r\n* Small footprint.\r\n* Feature minimized. Features can be added by modules.\r\n* Easy to get started.\r\n* Human readable namings.\r\n* Flat organization of module directories.\r\n* Proofed by unit testing \r\n* MIT license, to let modules choose their own way \r\n\r\nTODO\r\n====\r\n\r\n* Improve documentation\r\n* Improve documentation of the code\r\n* More unit testing\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}