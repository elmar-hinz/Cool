{"name":"Cool","tagline":"a tiny autowiring PHP framework","body":"======================================\r\nCool - a tiny autowiring PHP framework\r\n======================================\r\n\r\n * Author: Elmar Hinz <t3elmar@googlemail.com>\r\n * Homepage: \r\n * Version: 0.x.x\r\n * Stability: Alpha/Usable\r\n * License: MIT\r\n * Last update: See [ChangeLog](https://github.com/t3elmar/Cool/blob/master/ChangeLog)\r\n * OS: tested on POSIX i.e. Mac OS X, Unix, Linux, BSD\r\n * Dependencies: \r\n   * php > 5.3\r\n   * git (recommended for installation)\r\n * The dependencies ship under their own licenses and are not part of this program\r\n\t\r\nFeatures\r\n========\r\n\r\n- [x] Autowiring\r\n- [x] Singletons\r\n- [x] Services\r\n- [ ] Hooks\r\n- [x] Modularization\r\n- [x] Autoloading\r\n\r\nInstallation\r\n============\r\n\r\n\tgit clone git@github.com:t3elmar/Cool.git\r\n\r\nAutowiring - Dependency injection for dummies\r\n=============================================\r\n\r\n```php\r\nclass People { ... }\r\nclass Beer   { ... }\r\nclass Music  { ... } \r\n\r\nclass Party {\r\n\tfunction __construct(People $people, Beer $beer, Music $music) {\r\n\t\t...\r\n\t}\r\n}\r\n\r\n$container = new \\Cool\\Container();\r\n$party = $container->getInstance('Party');\r\n\r\n// And the party is up and running ...\r\n```\r\n\r\nAutowiring, the details\r\n-----------------------\r\n\r\nAutowiring is triggert by a call to `getInstance($classname)` \r\nof the container.  It is based on the signature of the constructor. \r\n\r\nFor each parameter a classname has to be declared. Else it fails.\r\nIt tries to to create an instance for each parameter \r\nby a recursive call to `getInstance`.\r\n\r\nIf `getInstance()` doesn't do what you want, you can still fall back\r\nto the static call to `new` or implement your own factory.\r\n\r\nFor sure ´getInstance´ supports the singleton management of the container.\r\n\r\nA later version of Cool will give the option to select the actual class\r\nto use for a paramter interface by configuration. That will be the moment\r\nit becomes real dependency injection, which real strength is flexibility, \r\nnot lazyness. \r\n\r\nSingletons\r\n==========\r\n\r\nBy implementing the interface `\\Cool\\Singleton` an object is managed as \r\nSingleton by the container, as long as it called by the conatainer\r\nmethods `getInstance`, `getService` or `getHook`.\r\n\r\n```php\r\nclass SantaClaus implements \\Cool\\Singleton { ... }\r\n```\r\n\r\nThe interface itself is empty. It serves as a flag.\r\n\r\nServices\r\n========\r\n\r\nA service is a class, that implements a service interface.\r\n\r\n```php\r\nclass PizzaCourier implements PizzaService { ... }\r\n```\r\n\r\nThis interface defines the type of the service and makes the class \r\na service at all. The interface must extend `\\Cool\\Service`.\r\n\r\n```php\r\ninterface PizzaService extends \\Cool\\Service { ... }\r\n```\r\n\r\nThe interface `\\Cool\\Service` has one method `canServe($mixedCriteria)`. \r\nThis is a **static** method, a class method. \r\n\r\nThe conatainer is called by `getService($serviceType , $mixedCriteria)`.\r\nIt nows asks all classes of the requested service type, if they could\r\nanswer the request, until the first one answers with TRUE. The\r\nservice type is the interface name of the service.\r\n\r\n```php\r\n$pizzaService = $container->getService(\r\n\t\t\t\t'MyModule\\PizzaService', array('dayOfWeek' => 'monday'));\r\n\r\n//  ... wiring some pizza services, \r\n//  all closed on monday, until suddenly ...\r\n\r\nclass PizzaCourier implements PizzaService {  \r\n\t// ...\r\n\tstatic public function canServe($mixedCriteria) { \r\n\t\treturn ($mixedCriteria['dayOfWeek'] != 'tuesday');\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n\r\nThe instantiation is done by `getInstance` again. That means that\r\na service must provide a construtor that satisfies the criteria of\r\n`getInstance`.\r\n\r\nIt depends on the service type, what it uses as $mixedCriteria and how\r\nit decides to answer with TRUE or FALSE based on this criteria.\r\n\r\nServices are autoregistered. They must stay in a module directory\r\nnamed `Services/` to work, while the interface definition belongs \r\ninto `Interfaces/`.\r\n\r\n\tMyModule/Interfaces/PizzaService.php\r\n\tMyModule/Services/PizzaCourier.php\r\n\r\nHooks\r\n=====\r\n\r\nNot implemented yet.\r\n\r\nModularization\r\n==============\r\n\r\nA module is created by putting a directory into `Modules`.\r\n\r\n\tCool/Modules/MyModule/\r\n\r\nThe Module hierarchy is flat. If you want to introduce hierarchy,\r\nyou have to do this in Form of the name. \r\n\r\n\tCool/Modules/MyCompanyMySuperModule/\r\n\r\nThe subdirectories `Interfaces`, `Classes`, `Hooks` and `Services`\r\nare the places where the autoloader is looking for. If your pathes\r\ndiffer from this, you have to provide your own loading mechanism.\r\n\r\n\tMyModule/Interfaces/\r\n\tMyModule/Classes/\r\n\tMyModule/Hooks/\r\n\tMyModule/Services/\r\n\r\nHooks and Services must stay in their matching directory to \r\nbe autoregistered.\r\n\r\n\tMyModule/Hooks/\r\n\tMyModule/Services/\r\n\r\nOther recommended Directories\r\n\r\n\tMyModule/Configuration/\r\n\tMyModule/Executables/\r\n\tMyModule/Documentation/\r\n\tMyModule/Tests/\r\n\r\n\r\nCoding guidelines\r\n=================\r\n\r\nThe coding guidelines are recommendations. They don't differ from\r\nthe up-to-date mainstream:\r\n\r\n* Use CamelCase as far as possible.\r\n* Classnames start uppercase, functions and variables lowercase.\r\n* Constants are all uppercase: TRUE, FALSE \r\n* Respect the security requirements of PHP programming\r\n* Wrap all PHP code into classes, even configurations.\r\n* Use namespaces.\r\n* Write configurations as PHP array for now.\r\n* Put a license in your module.\r\n* When you call code from other moduels, adhere their licences.\r\n  They may not be as liberal as the Cool framework itself.\r\n\r\n\r\nGoals of the design\r\n===================\r\n\r\n* Small footprint.\r\n* Feature minimized. Features can be added by modules.\r\n* Easy to get started.\r\n* Human readable namings.\r\n* Flat organization of module directories.\r\n* Proofed by unit testing \r\n* MIT license, to let modules choose their own way \r\n\r\nTODO\r\n====\r\n\r\n* Improve documentation\r\n* Improve documentation of the code\r\n* More unit testing\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}