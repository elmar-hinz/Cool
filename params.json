{"name":"Cool","tagline":"a tiny autowiring PHP framework","body":"======================================\r\nCool - a tiny autowiring PHP framework\r\n======================================\r\n\r\n * Author: Elmar Hinz <t3elmar@googlemail.com>\r\n * Homepage: \r\n * Version: 0.x.x\r\n * Stability: Alpha/Usable\r\n * License: MIT\r\n * Last update: See [ChangeLog](https://github.com/t3elmar/Cool/blob/master/ChangeLog)\r\n * OS: tested on POSIX i.e. Mac OS X, Unix, Linux, BSD\r\n * Dependencies: \r\n   * php > 5.3\r\n   * git (recommended for installation)\r\n * The dependencies ship under their own licenses and are not part of this program\r\n\t\r\nFeatures\r\n========\r\n\r\n- [x] Autowiring\r\n- [x] Singletons\r\n- [x] Services\r\n- [x] Signals, Receivers\r\n- [x] Modularization\r\n- [x] Autoloading\r\n\r\nInstallation\r\n============\r\n\r\n\tgit clone git@github.com:t3elmar/Cool.git\r\n\r\nAutowiring - Dependency injection for dummies\r\n=============================================\r\n\r\n```php\r\nclass People { ... }\r\nclass Beer   { ... }\r\nclass Music  { ... } \r\n\r\nclass Party {\r\n\tfunction __construct(People $people, Beer $beer, Music $music) {\r\n\t\t...\r\n\t}\r\n}\r\n\r\n$container = new \\Cool\\Container();\r\n$party = $container->getInstance('Party');\r\n\r\n// And the party is up and running ...\r\n```\r\n\r\nAutowiring, the details\r\n-----------------------\r\n\r\nAutowiring is triggert by a call to `getInstance($classname)` \r\nof the container.  It is based on the signature of the constructor. \r\n\r\nFor each parameter in the construtor definition a classname has \r\nto be specified. Else it doesn't works and an error is thrown. \r\nIt tries to to create an instance for each parameter \r\nby a recursive call to `getInstance`.\r\n\r\nIf `getInstance()` doesn't do what you want, you can still fall back\r\nto the static call to `new` or implement your own factory.\r\n\r\n### Out-look ###\r\n\r\n> The recursive auto-instantiation of objects is a nice feature,\r\n> but not the definition and strength of dependency injection.\r\n> The strenght is flexibility. Future versions will provide mechanism,\r\n> to replace classes (or interfaces in general) by subclasses \r\n> through configuration.\r\n\r\nSingletons\r\n==========\r\n\r\nBy implementing the interface `\\Cool\\Singleton` an object is managed as \r\nSingleton by the container, as long as it called by the conatainer\r\nmethods `getInstance` or `getService`.\r\n\r\n```php\r\nclass SantaClaus implements \\Cool\\Singleton { ... }\r\n```\r\n\r\nThe interface itself is empty. It serves as a flag.\r\n\r\nServices\r\n========\r\n\r\nA service is a class, that implements a service interface.\r\n\r\n```php\r\nclass PizzaCourier implements PizzaService { ... }\r\n```\r\n\r\nThis interface defines the type of the service. \r\nIt must extend `\\Cool\\Service`.\r\n\r\n```php\r\ninterface PizzaService extends \\Cool\\Service { ... }\r\n```\r\n\r\nInterface `\\Cool\\Service` has one class method `canServe($mixedCriteria)`.\r\n\r\nWhen it's method `getService($serviceType , $mixedCriteria)` is called,\r\nthe container asks all classes of the given service type, if they \r\ncould serve the request. The first service that answers with TRUE \r\nis the winner. It is instantiated and returned ready to do the job. \r\n\r\n### Out-look ###\r\n> This is the most simple algorythm to find the winnig service, but it's \r\n> simplicity by intention. Inject your own finders in future versions.\r\n\r\n```php\r\n// ... Concierge get me a pizza service! \r\n// ... We have a surprising monday party and the fridge is empty.\r\n\r\n$pizzaService = $container->getService(\r\n\t\t\t\t'MyModule\\PizzaService', array('dayOfWeek' => 'monday'));\r\n\r\n//  Concierge wiring some pizza services, \r\n//  all closed on monday, until suddenly ...\r\n\r\nclass PizzaCourier implements PizzaService {  \r\n\t// ...\r\n\tstatic public function canServe($mixedCriteria) { \r\n\t\treturn ($mixedCriteria['dayOfWeek'] != 'tuesday');\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n\r\n### Hint ###\r\n\r\n> It depends on the service type, what `canServe` uses as $mixedCriteria \r\n> and how it evaluates its answer. If you don't set a stricter type for\r\n> $mixedCriteria in the interface definition,  you should at least \r\n> document it in that place.\r\n\r\n### Hint ###\r\n\r\n> canServe is a **static** method, a **class method**.\r\n>\r\n> To get inheritance work with static methods and variables,\r\n> **late static bindings** are your friends:\r\n> http://www.php.net/manual/en/language.oop5.late-static-bindings.php\r\n\r\nServices are autoregistered. They must stay in a module directory\r\nnamed `Services/` to work, while the interface definition belongs \r\ninto `Interfaces/`.\r\n\r\n\tMyModule/Interfaces/PizzaService.php\r\n\tMyModule/Services/PizzaCourier.php\r\n\r\n### Hint ###\r\n\r\n> Instantiation is delegated to `getInstance`. That means that a service \r\n> must provide a construtor that satisfies the criteria of `getInstance`.\r\n\r\nSignals and Receivers\r\n=====================\r\n\r\nSignals are messesages, that are send at certain events in the code,\r\nto inform others about them. They are typically targeted to be used \r\nby other modules. Hence, they are designed to support the other \r\ndevelopers as far as possible.\r\n\r\n### 1.) Visibility \r\n\r\nSignals are declared as classes in the module directory `Signals` to give them visibiltiy.\r\n\r\n### 2.) Documentation \r\n\r\nThe very same place is targeted to document them.\r\n\r\n### 3.) Augmentation \r\n\r\nSignals may be augmented by special getters to make them \r\nmore easy and intuitive to use by the receivers.\r\n\r\nSignals\r\n-------\r\n\r\nThey create and broadcast themself, by extending the class `AbstractSignal`,\r\nthat itself implementes the interface `\\Cool\\Signal`. \r\n\r\n```php\r\nclass MySignal extends \\Cool\\AbstractSignal { ... }\r\n```\r\nSignals are called by the static message send.  \r\n\r\nThere is nothing like signal injection, because signals are strongly\r\nrelated to the class they are send by.\r\n\r\n```php\r\nMySignal::send($this, $optionallyMixedData);\r\n```\r\n\r\nThe first parameter of `send` is the sending object. \r\nThe second parameter is optionally any data that is expected by the signal.\r\n\r\n```php\r\nclass MySpcialSignal extends \\Cool\\AbstractSignal { \r\n\r\n\t/**\r\n\t* @param object the sender\r\n\t* @param \\SpecialClass the special data\r\n\t*/\r\n\tstatic function send($sender, $specialObject) {\r\n\t\tassert($specialObject instanceOf \\SpecialClass);\r\n\t\tparent::send($sender, $specialObject);\r\n\t}\r\n\r\n\t/**\r\n\t* @return \\SpecialClass the special data\r\n\t*/\r\n\tfunction getSpecialObject() {\r\n\t\treturn $this->getData();\r\n\t}\r\n}\r\n```\r\n\r\nThe method `send` can be specialized and special getters can by added.\r\n\r\nThe sender can by accessed by the method `getSender()`.\r\n\r\nReceivers\r\n---------\r\n\r\nReceivers implement the interface `\\Cool\\Receivers`. They stay in the\r\nmodule directory `Receivers`. The static method `listensTo` returns\r\nthe implementation of `\\Cool\\Signal` to listen to. That is all to\r\nbe done to register a receiver.\r\n\r\nIt's up to the receiver what to do with the signal.\r\n\r\n```php\r\nclass MyReceiver implements \\Cool\\Receiver { \r\n\r\n\tstatic functions listensTo() { return 'MySignal'; }\r\n\r\n\t/**\r\n\t* @param MySignal the expected signal\r\n\t*/\r\n\tfunction receive(\\Cool\\Signal $signal) { \r\n\t\tassert($signal instanceOf self::listensTo());\r\n\t\t...  \r\n\t}\r\n\r\n}\r\n```\r\n\r\nUsing signals as hooks\r\n----------------------\r\n\r\nThe static method `send` of the signal returns an iterator `\\Cool\\Receivers`\r\nwith all the listening receivers. By iterating the receivers and calling\r\nmethods on them the signalling mechanism can be used like a hook.\r\n\r\nFor this to work the listening receivers must provide the method that is\r\ncalled by the sender, to hook them in.\r\n\r\n```php\r\nclass MyClass { \r\n\r\n\tfunction myFunction() { \r\n\t\t$receivers = MySignal::send($this);\r\n\t\tforeach($receivers as $receiver) {\r\n\t\t\t$receiver->doSomthing();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n```\r\n\r\nIt is a good idea to provide a hook interface defining the methods the\r\nreceiver must implement to be usable by this hook.\r\n\r\n```php\r\n\tfunction myFunction() { \r\n\t\t$receivers = MySignal::send($this);\r\n\t\tforeach($receivers as $receiver) {\r\n\t\t\tif(!$receiver isInstanceOf MyHookInterface) throw new Exception('invalid hook');\r\n\t\t\t$receiver->doSomthing();\r\n\t\t}\r\n\t}\r\n```\r\n\r\n\r\nModularization\r\n==============\r\n\r\nA module is created by putting a directory into `Modules`.\r\n\r\n\tCool/Modules/MyModule/\r\n\r\nThe Module hierarchy is flat. If you want to introduce hierarchy,\r\nyou have to do this in Form of the name. \r\n\r\n\tCool/Modules/MyCompanyMySuperModule/\r\n\r\nThe subdirectories `Interfaces`, `Classes`, `Services`, `Signals` \r\nand `Receivers` are the places where the autoloader is looking for. If your \r\npathes differ from this, you have to provide your own loading mechanism.\r\n\r\n\tMyModule/Interfaces/\r\n\tMyModule/Classes/\r\n\tMyModule/Services/\r\n\tMyModule/Signals/\r\n\tMyModule/Receivers/\r\n\r\nServices and Receivers must stay in their matching directory to \r\nbe autoregistered.\r\n\r\n\tMyModule/Services/\r\n\tMyModule/Receivers/\r\n\r\nOther recommended Directories\r\n\r\n\tMyModule/Configuration/\r\n\tMyModule/Executables/\r\n\tMyModule/Documentation/\r\n\tMyModule/Tests/\r\n\r\nCoding guidelines\r\n=================\r\n\r\nThe coding guidelines are recommendations. They don't differ from\r\nthe up-to-date mainstream:\r\n\r\n* Use CamelCase as far as possible.\r\n* Classnames start uppercase, functions and variables lowercase.\r\n* Constants are all uppercase: TRUE, FALSE \r\n* Respect the security requirements of PHP programming\r\n* Wrap all PHP code into classes, even configurations.\r\n* Use namespaces.\r\n* Write configurations as PHP array for now.\r\n* Put a license into your module.\r\n* When you call code from other modules, adhere their licences.\r\n  They may not be as liberal as the Cool framework itself.\r\n\r\n\r\nGoals of the design\r\n===================\r\n\r\n* Small footprint.\r\n* Feature minimized. Features can be added by modules.\r\n* Easy to get started.\r\n* Human readable namings.\r\n* Flat organization of module directories.\r\n* Proofed by unit testing \r\n* MIT license, to let modules choose their own way \r\n\r\n\r\nHello World\r\n===========\r\n\r\nHello world as a service.\r\n\r\nSetting up directories\r\n----------------------\r\n\r\n```sh\r\ncd Cool/Modules/\r\nmkdir HelloWorld/\r\ncd HelloWorld/\r\nmkdir Executables Configuration Interfaces Classes Services\r\n```\r\n\r\nGreeterService interface\r\n------------------------\r\nPath `Interfaces/GreeterService.php`:\r\n```php\r\n<?php namepace HelloWorld;\r\ninterface GreeterService extends \\Cool\\Service {\r\n\t// expects morning | evening| other string\r\n\tpublic static CanServe($timeOfDay);\r\n\tpublic greet($name);\r\n}\r\n?>\r\n```\r\n\r\nGreeter services\r\n----------------\r\nPath `Services/MorningGreeter.php`:\r\n```php\r\n<?php namepace HelloWorld;\r\nclass MorningGreeter implements GreeterService {\r\n\tstatic public CanServe($timeOfDay) { return $timeOfDay == 'morning'; }\r\n\tpublic greet($name) { print 'Good morning, '.$name.'!'; }\r\n}\r\n?>\r\n```\r\n\r\nPath `Services/EveningGreeter.php`:\r\n```php\r\n<?php namepace HelloWorld;\r\nclass EveningGreeter implements GreeterService {\r\n\tstatic public CanServe($timeOfDay) { return $timeOfDay == 'evening'; }\r\n\tpublic greet($name) { print 'Good evening, '.$name.'!'; }\r\n}\r\n?>\r\n```\r\nPath `Services/DefaultGreeter.php`:\r\n```php\r\n<?php namepace HelloWorld;\r\nclass DefaultGreeter implements GreeterService {\r\n\tstatic public canServe($timeOfDay) { \r\n\t\treturn $timeOfDay != 'evening' && $timeOfDay != 'morning'; }\r\n\tpublic greet($name) { print 'Hello '.$name.'!'; }\r\n}\r\n?>\r\n```\r\n\r\nThe program\r\n-----------\r\nPath `Classes/HelloWorld.php`:\r\n\r\n```php\r\n<?php namepace HelloWorld;\r\nclass Program {\r\n\tprivate $container;\r\n\r\n\t// The container (a singleton) will inject itself. \r\n\tpublic function __construct(\\Cool\\Container $container) {\r\n\t\t$this->container = $container;\r\n\t}\r\n\r\n\tpublic function go($name) {\r\n\t\t$timeOfDay = $this->getTimeOfDay();\r\n\t\t$container->getService('HelloWorld\\GreeterService', $timeOfDay)->greet($name);\r\n\t}\r\n\r\n\t// returns a string: morning | evening | other\r\n\tpublic function getTimeOfDay() { ... }\r\n\r\n}\r\n?>\r\n```\r\n\r\nConfiguration\r\n-------------\r\nPath `Configuration/Main.php`:\r\n```php\r\n<?php namepace HelloWorld;\r\nclass Main {\r\n\tstatic public main($argv) { \r\n\t\t$moduleBase = __DIR__.'/../..';\r\n\t\trequire_once($moduleBase.'/Cool/Classes/AutoLoader.php');\r\n\t\t$loader = new \\Cool\\AutoLoader();\r\n\t\t$loader->addModuleBase($moduleBase);\r\n\t\t$loader->go();\r\n\t\t$loader = new \\Cool\\DedicatedDirectoriesLoader();\r\n\t\t$loader->addModuleBase($moduleBase);\r\n\t\t$loader->go();\r\n\t\t$container = new \\Cool\\Container();\r\n\t\t$program = $container->getInstance('HelloWorld\\Program');\r\n\t\t// the user provides his name as argument\r\n\t\t$program->go($argv[1]);\r\n\t}\r\n}\r\n?>\r\n```\r\n\r\nExecutable\r\n----------\r\nPath `Executables/sayHello.sh`:\r\n```php\r\n#! /usr/bin/env php\r\n<?php\r\nrequire_once(__DIR__.\"/../Configuration/Main.php\");\r\n\\HelloWorld\\Main::main($argv);\r\n?>\r\n```\r\nmake it executable:\r\n```sh\r\nchmod +x Executables/sayHello.sh\r\n```\r\n\r\nTODO\r\n====\r\n\r\n* Signals and Receivers\r\n* Add customized finders\r\n* Improve documentation\r\n* Improve documentation of the code\r\n* More unit testing\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}